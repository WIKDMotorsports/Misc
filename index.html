<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hotspot Builder — Single File</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#7c3aed;--muted:#9aa4b2;}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6;background:linear-gradient(180deg,#071027 0%, #07122a 60%);}
    .app{display:grid;grid-template-columns:380px 1fr;gap:18px;padding:18px;height:100vh;box-sizing:border-box}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:14px;box-shadow:0 6px 20px rgba(2,6,23,0.6);overflow:auto}
    h2{margin:6px 0 12px;font-size:16px}
    .drop{border:2px dashed rgba(255,255,255,0.04);padding:14px;border-radius:8px;min-height:84px;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:8px}
    .files{margin-top:10px;display:flex;flex-direction:column;gap:8px}
    .file{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);cursor:pointer}
    .file.selected{outline:2px solid rgba(124,58,237,0.18)}
    .thumb{width:56px;height:40px;object-fit:cover;border-radius:6px}
    .meta{font-size:13px;color:var(--muted)}
    .viewer{display:flex;flex-direction:column;height:100%}
    .canvas-wrap{flex:1;display:flex;align-items:center;justify-content:center;padding:18px}
    .image-box{position:relative;display:inline-block;border-radius:8px;background:#081021;padding:6px}
    img#main{display:block;max-width:100%;height:auto;border-radius:6px;user-select:none}
    .marker{position:absolute;width:18px;height:18px;border-radius:50%;border:2px solid white;box-shadow:0 2px 6px rgba(0,0,0,0.6);transform:translate(-50%,-50%);display:flex;align-items:center;justify-content:center;background:var(--accent);color:white;font-size:11px;cursor:grab}
    .marker.dragging{cursor:grabbing;opacity:0.9}
    .controls{display:flex;gap:8px;align-items:center;margin-top:12px}
    button{background:linear-gradient(180deg,var(--accent),#5b21b6);border:0;padding:8px 10px;border-radius:8px;color:white;cursor:pointer}
    .muted-btn{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    .inputs{display:flex;gap:8px;align-items:center;margin-top:10px}
    label{font-size:13px;color:var(--muted)}
    input[type='text']{padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    textarea{width:100%;height:120px;background:transparent;color:inherit;border-radius:8px;border:1px solid rgba(255,255,255,0.04);padding:8px}
    footer{font-size:12px;color:var(--muted);margin-top:12px}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .hotspot-list{margin-top:8px;display:flex;flex-direction:column;gap:6px}
    .hotspot-item{display:flex;justify-content:space-between;gap:6px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <div class="topbar">
        <h2>Hotspot Builder</h2>
        <div class="small">Single-file • Local • No backend</div>
      </div>

      <div class="drop" id="drop">
        <div style="font-weight:600">Drag & drop images here</div>
        <div class="small">Supports JPG, PNG, WebP. Click to browse.</div>
        <input id="fileinput" type="file" accept="image/*" multiple style="display:none" />
      </div>

      <div class="files" id="filelist" aria-live="polite"></div>

      <div style="margin-top:12px;display:flex;gap:6px;flex-wrap:wrap">
        <button id="exportJson">Export JSON</button>
        <button id="importJson" class="muted-btn">Import JSON</button>
        <button id="downloadAllAnnotated" class="muted-btn">Download Annotated Images</button>
        <button id="downloadXMP" class="muted-btn">Download .XMP Sidecars</button>
      </div>

      <div style="margin-top:12px">
        <label class="small">Bulk JSON output (preview)</label>
        <textarea id="jsonPreview" readonly></textarea>
      </div>

      <footer>Tips: click an image to select → click on the image to add marker → drag to move → right-click to delete. Export to JSON or XMP sidecar.</footer>
    </div>

    <div class="panel viewer">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
        <div>
          <h2 id="imgTitle">No image selected</h2>
          <div class="meta" id="imgMeta"></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <label class="small">Label:</label>
          <input type="text" id="currentLabel" placeholder="marker label" />
          <button id="toggleLabels" class="muted-btn">Toggle Labels</button>
          <button id="downloadAnnotated" class="muted-btn">Download Annotated</button>
          <button id="embedUserComment" class="muted-btn">Embed JSON in JPEG (UserComment)</button>
        </div>
      </div>

      <div class="canvas-wrap">
        <div class="image-box" id="imageBox">
          <img id="main" src="" alt="" draggable="false" />
        </div>
      </div>

      <div class="controls">
        <div class="small">Click on the image to add a hotspot at that pixel. Markers are stored relative to the image's natural resolution.</div>
      </div>

      <div style="margin-top:12px">
        <div style="display:flex;gap:8px;align-items:center">
          <label class="small">Hotspots</label>
          <div id="hotCount" class="small"></div>
        </div>
        <div class="hotspot-list" id="hotspotList"></div>
      </div>
    </div>
  </div>

<script>
// Single-file Hotspot Builder JS
// Features implemented:
// - Drag/drop or browse to load images (multiple)
// - Click to add hotspot (saved as absolute pixel coords relative to naturalWidth/naturalHeight)
// - Drag to reposition markers
// - Right-click marker to delete
// - Edit label for marker
// - Export JSON bulk; Import JSON
// - Download annotated image (PNG) per-image or bulk
// - Download .xmp sidecar files containing JSON for each image
// - Embed JSON into JPEG's Exif UserComment (best-effort using piexifjs, if image is JPEG)

// State
const state = { images: [], selectedIndex: -1 };

// Utilities
function uid(len=6){return Math.random().toString(36).slice(2,2+len)}
function readFileAsDataURL(file){return new Promise((res,rej)=>{const r=new FileReader();r.onload=()=>res(r.result);r.onerror=rej;r.readAsDataURL(file)})}

// DOM
const drop = document.getElementById('drop');
const fileinput = document.getElementById('fileinput');
const filelist = document.getElementById('filelist');
const mainImg = document.getElementById('main');
const imageBox = document.getElementById('imageBox');
const imgTitle = document.getElementById('imgTitle');
const imgMeta = document.getElementById('imgMeta');
const hotspotList = document.getElementById('hotspotList');
const jsonPreview = document.getElementById('jsonPreview');
const exportJsonBtn = document.getElementById('exportJson');
const importJsonBtn = document.getElementById('importJson');
const downloadAnnotatedBtn = document.getElementById('downloadAnnotated');
const downloadAllAnnotatedBtn = document.getElementById('downloadAllAnnotated');
const downloadXMPBtn = document.getElementById('downloadXMP');
const currentLabel = document.getElementById('currentLabel');
const toggleLabelsBtn = document.getElementById('toggleLabels');
const embedUserCommentBtn = document.getElementById('embedUserComment');

let showLabels = true;

// File handling
drop.addEventListener('click',()=>fileinput.click());
fileinput.addEventListener('change', async(e)=>{await handleFiles([...e.target.files]); fileinput.value='';});

['dragenter','dragover','dragleave','drop'].forEach(ev=>drop.addEventListener(ev,(e)=>{e.preventDefault();e.stopPropagation();}));
drop.addEventListener('drop',async(e)=>{const files=[...e.dataTransfer.files].filter(f=>f.type.startsWith('image/')); await handleFiles(files);});

async function handleFiles(files){
  for(const file of files){
    try{
      const url = await readFileAsDataURL(file);
      const img = new Image();
      await new Promise((res,rej)=>{img.onload=res;img.onerror=rej;img.src=url});
      const entry = { id: uid(8), name: file.name, fileType:file.type, dataURL: url, naturalWidth: img.naturalWidth, naturalHeight: img.naturalHeight, hotspots: [] };
      state.images.push(entry);
    }catch(err){console.warn('failed to load',file.name,err)}
  }
  renderFileList();
  if(state.selectedIndex===-1 && state.images.length>0) selectImage(0);
  updatePreviewJSON();
}

function renderFileList(){
  filelist.innerHTML='';
  state.images.forEach((it,i)=>{
    const el=document.createElement('div');el.className='file'+(i===state.selectedIndex?' selected':'');
    el.innerHTML=`<img class='thumb' src='${it.dataURL}'/><div style='flex:1'><div style='font-weight:600'>${it.name}</div><div class='meta'>${it.naturalWidth}×${it.naturalHeight} • ${it.hotspots.length} hotspots</div></div>`;
    el.addEventListener('click',()=>selectImage(i));
    filelist.appendChild(el);
  })
}

function selectImage(index){
  state.selectedIndex=index;
  const it=state.images[index];
  mainImg.src = it.dataURL;
  imgTitle.textContent = it.name;
  imgMeta.textContent = `${it.naturalWidth} × ${it.naturalHeight} • ${it.hotspots.length} hotspots`;
  renderFileList();
  renderMarkers();
  updateHotspotList();
}

// Markers
function renderMarkers(){
  // remove existing
  document.querySelectorAll('.marker').forEach(n=>n.remove());
  const idx = state.selectedIndex; if(idx<0) return;
  const it = state.images[idx];
  it.hotspots.forEach((h, i) => {
    const el = document.createElement('div');
    el.className='marker';
    el.dataset.index = i;
    el.title = h.label || '';
    if(showLabels) el.textContent = h.label ? (h.label.length>2? h.label[0] : h.label) : i+1;
    else el.textContent='';
    positionMarker(el, h);
    makeDraggable(el, h, it);
    el.addEventListener('contextmenu', (ev)=>{ev.preventDefault(); deleteHotspot(i);});
    imageBox.appendChild(el);
  });
}

function positionMarker(el, h){
  const scaleX = mainImg.clientWidth / mainImg.naturalWidth;
  const scaleY = mainImg.clientHeight / mainImg.naturalHeight;
  const left = (h.x / mainImg.naturalWidth) * mainImg.clientWidth;
  const top = (h.y / mainImg.naturalHeight) * mainImg.clientHeight;
  el.style.left = left + 'px';
  el.style.top = top + 'px';
}

function imgClientToNatural(clientX, clientY){
  const rect = mainImg.getBoundingClientRect();
  const cx = Math.min(Math.max(0, clientX - rect.left), rect.width);
  const cy = Math.min(Math.max(0, clientY - rect.top), rect.height);
  const nx = Math.round((cx / rect.width) * mainImg.naturalWidth);
  const ny = Math.round((cy / rect.height) * mainImg.naturalHeight);
  return { x: nx, y: ny };
}

mainImg.addEventListener('click',(e)=>{
  if(state.selectedIndex<0) return;
  const label = currentLabel.value.trim();
  const { x,y } = imgClientToNatural(e.clientX, e.clientY);
  const it = state.images[state.selectedIndex];
  it.hotspots.push({ x,y,label,id:uid(6) });
  renderMarkers(); updateHotspotList(); renderFileList(); updatePreviewJSON();
});

function deleteHotspot(i){
  if(state.selectedIndex<0) return;
  const it = state.images[state.selectedIndex];
  it.hotspots.splice(i,1);
  renderMarkers(); updateHotspotList(); renderFileList(); updatePreviewJSON();
}

function makeDraggable(el, hotspot, imageEntry){
  let dragging=false, startX=0, startY=0;
  el.addEventListener('mousedown', (e)=>{
    e.preventDefault(); dragging=true; el.classList.add('dragging');
    startX = e.clientX; startY = e.clientY;
    document.addEventListener('mousemove', onmove);
    document.addEventListener('mouseup', onup, {once:true});
  });
  function onmove(e){
    if(!dragging) return;
    const rect = mainImg.getBoundingClientRect();
    const cx = Math.min(Math.max(0, e.clientX - rect.left), rect.width);
    const cy = Math.min(Math.max(0, e.clientY - rect.top), rect.height);
    const nx = Math.round((cx / rect.width) * mainImg.naturalWidth);
    const ny = Math.round((cy / rect.height) * mainImg.naturalHeight);
    hotspot.x = nx; hotspot.y = ny;
    positionMarker(el, hotspot);
    updateHotspotList(); updatePreviewJSON();
  }
  function onup(){ dragging=false; el.classList.remove('dragging'); document.removeEventListener('mousemove', onmove); }
}

function updateHotspotList(){
  hotspotList.innerHTML='';
  if(state.selectedIndex<0) { document.getElementById('hotCount').textContent=''; return }
  const it = state.images[state.selectedIndex];
  document.getElementById('hotCount').textContent = `${it.hotspots.length}`;
  it.hotspots.forEach((h,i)=>{
    const el = document.createElement('div'); el.className='hotspot-item';
    el.innerHTML = `<div style='flex:1'><strong>${i+1}</strong> <span class='small'>${h.label||''}</span><div class='small'>x:${h.x} y:${h.y}</div></div><div style='display:flex;gap:6px'><button class='muted-btn' data-action='edit'>Edit</button><button class='muted-btn' data-action='zoom'>Jump</button></div>`;
    el.querySelectorAll('button').forEach(btn=>{
      btn.addEventListener('click',(ev)=>{
        const act = btn.dataset.action;
        if(act==='edit'){ const newLabel = prompt('New label', h.label||''); if(newLabel!==null){ h.label=newLabel; renderMarkers(); updateHotspotList(); updatePreviewJSON(); }}
        if(act==='zoom'){ // no zoom, but move viewport by setting scroll to image
          // center imageBox viewport to marker
          const rect = mainImg.getBoundingClientRect(); const cx=(h.x/mainImg.naturalWidth)*rect.width + rect.left; window.scrollTo({left: Math.max(0,cx-200), behavior:'smooth'});
        }
      })
    });
    hotspotList.appendChild(el);
  });
}

// Exports & imports
function buildExport(){
  return state.images.map(it=>({ name:it.name, naturalWidth:it.naturalWidth,naturalHeight:it.naturalHeight,fileType:it.fileType, hotspots: it.hotspots }));
}

exportJsonBtn.addEventListener('click', ()=>{
  const data = buildExport();
  const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='hotspots.json'; a.click(); URL.revokeObjectURL(url);
});

importJsonBtn.addEventListener('click', ()=>{
  const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json'; inp.onchange = async(e)=>{
    const f = e.target.files[0]; if(!f) return; const txt = await f.text(); try{ const data = JSON.parse(txt); // merge by name where possible
      data.forEach(remote=>{
        const local = state.images.find(x=>x.name===remote.name);
        if(local){ local.hotspots = remote.hotspots || []; }
      }); renderMarkers(); renderFileList(); updateHotspotList(); updatePreviewJSON(); alert('Imported'); }catch(err){alert('Bad JSON')}
  }; inp.click();
});

function updatePreviewJSON(){ jsonPreview.value = JSON.stringify(buildExport(), null, 2); }

// Annotated image download (draw markers onto canvas)
function annotatedCanvasForImage(it){
  return new Promise((res,rej)=>{
    const img = new Image(); img.onload = ()=>{
      const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight; const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0);
      // draw markers
      it.hotspots.forEach((h,i)=>{
        const r = Math.max(6, Math.round(Math.min(canvas.width, canvas.height)/60));
        ctx.beginPath(); ctx.fillStyle = '#7c3aed'; ctx.strokeStyle = '#fff'; ctx.lineWidth = Math.max(2, r/3);
        ctx.arc(h.x, h.y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        if(h.label){ ctx.font = Math.round(r*1.2)+'px sans-serif'; ctx.fillStyle='white'; ctx.fillText(h.label, h.x + r + 6, h.y + (r/2)); }
      });
      res(canvas);
    }; img.onerror = rej; img.src = it.dataURL;
  });
}

downloadAnnotatedBtn.addEventListener('click', async()=>{
  if(state.selectedIndex<0) return alert('Select an image');
  const it = state.images[state.selectedIndex];
  const canvas = await annotatedCanvasForImage(it);
  canvas.toBlob(blob=>{ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download = it.name.replace(/\.[^.]+$/,'') + '-annotated.png'; a.click(); URL.revokeObjectURL(url); });
});

downloadAllAnnotatedBtn.addEventListener('click', async()=>{
  for(const it of state.images){ const canvas = await annotatedCanvasForImage(it); await new Promise(res=>canvas.toBlob(blob=>{ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download = it.name.replace(/\.[^.]+$/,'') + '-annotated.png'; a.click(); URL.revokeObjectURL(url); setTimeout(res,120); })); }
});

// XMP sidecar generation (simple wrapper embedding our JSON in a <x:xmpmeta> tag as <rdf:Description Hotspots='...'>)
function xmpForEntry(it){
  const hotspotsJSON = JSON.stringify({ name:it.name, naturalWidth:it.naturalWidth, naturalHeight:it.naturalHeight, hotspots: it.hotspots });
  const xml = `<?xpacket begin=\"\uFEFF\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\n<x:xmpmeta xmlns:x=\"adobe:ns:meta/\">\n<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n<rdf:Description rdf:about=\"\" xmlns:hs=\"http://example.com/hotspots/1.0/\" hs:hotspots='${hotspotsJSON.replace(/'/g,"&apos;")}' />\n</rdf:RDF>\n</x:xmpmeta>\n<?xpacket end=\"w\"?>`;
  return xml;
}

downloadXMPBtn.addEventListener('click', ()=>{
  for(const it of state.images){ const xmp = xmpForEntry(it); const blob = new Blob([xmp],{type:'application/xml'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download = it.name.replace(/\.[^.]+$/,'') + '.xmp'; a.click(); URL.revokeObjectURL(url); }
});

// Embed JSON into JPEG UserComment using piexifjs if JPEG
embedUserCommentBtn.addEventListener('click', async()=>{
  if(state.selectedIndex<0) return alert('Select an image');
  const it = state.images[state.selectedIndex];
  if(!it.fileType.includes('jpeg') && !it.fileType.includes('jpg')) return alert('Embedding to EXIF is only supported for JPEG files in this tool.');

  // lazy load piexifjs
  if(typeof piexif === 'undefined'){
    await loadScript('https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js');
  }
  try{
    const hotspotsJSON = JSON.stringify({ name:it.name, naturalWidth:it.naturalWidth, naturalHeight:it.naturalHeight, hotspots: it.hotspots });
    const encoded = piexif.dump({Exif:{UserComment: piexif._getExifByteArray(hotspotsJSON)}});
    const newData = piexif.insert(encoded, it.dataURL);
    // download new JPEG
    const a=document.createElement('a'); a.href=newData; a.download = it.name.replace(/\.[^.]+$/,'') + '-with-hotspots.jpg'; a.click();
    alert('Downloaded JPEG with UserComment (best-effort). Note: not all viewers show UserComment.');
  }catch(err){console.error(err); alert('Failed to embed EXIF: '+err.message)}
});

function loadScript(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=rej;document.head.appendChild(s)})}

// Toggle labels
toggleLabelsBtn.addEventListener('click', ()=>{ showLabels = !showLabels; renderMarkers(); toggleLabelsBtn.textContent = showLabels? 'Hide Labels' : 'Show Labels'; });

// Keep marker positions updated on window resize / image resize
new ResizeObserver(()=>{ renderMarkers(); }).observe(mainImg);

// keyboard shortcuts
window.addEventListener('keydown',(e)=>{
  if(e.key==='n') { // next image
    if(state.images.length===0) return; const idx = (state.selectedIndex+1)%state.images.length; selectImage(idx);
  }
  if(e.key==='ArrowRight'){ if(state.images.length===0) return; const idx = Math.min(state.selectedIndex+1, state.images.length-1); selectImage(idx); }
  if(e.key==='ArrowLeft'){ if(state.images.length===0) return; const idx = Math.max(0, state.selectedIndex-1); selectImage(idx); }
});

// small helpful UX: clicking on a file in list focuses it

// initialize
updatePreviewJSON();

</script>
</body>
</html>


//Video version

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Video Hotspot Builder — Full God Mode</title>
  <style>
    :root{--bg:#071127;--panel:#071a2a;--muted:#9fb0c9;--accent:#ff7b72;--accent2:#7c3aed}
    *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{margin:0;height:100vh;background:linear-gradient(180deg,#041026 0%,#071127 100%);color:#e6eef6}
    .app{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px;height:100%}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:10px;padding:12px;overflow:auto}
    h1{margin:6px 0;font-size:16px}
    .controls{display:flex;gap:8px;align-items:center}
    .muted{color:var(--muted);font-size:13px}
    .drop{border:2px dashed rgba(255,255,255,0.03);padding:10px;border-radius:8px;display:flex;flex-direction:column;align-items:center;gap:6px}
    input[type=file]{display:none}
    .mini{font-size:12px;color:var(--muted)}
    .video-wrap{position:relative;display:flex;flex-direction:column;align-items:center}
    .player-area{position:relative;background:#031423;border-radius:8px;padding:8px}
    video{display:block;max-width:100%;height:auto;border-radius:6px;background:#000}
    .marker{position:absolute;width:18px;height:18px;border-radius:50%;transform:translate(-50%,-50%);display:flex;align-items:center;justify-content:center;background:var(--accent2);color:white;border:2px solid #fff;cursor:grab}
    .marker.dragging{opacity:0.9;cursor:grabbing}
    .timeline{display:flex;gap:8px;align-items:center;margin-top:10px}
    .timeline input[type=range]{flex:1}
    .hotspot-list{margin-top:10px;display:flex;flex-direction:column;gap:8px}
    .hotspot-card{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:6px}
    .kf-list{display:flex;flex-wrap:wrap;gap:6px}
    button{background:linear-gradient(180deg,var(--accent),#b43a34);border:0;padding:8px 10px;border-radius:8px;color:white;cursor:pointer}
    .muted-btn{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px}
    textarea{width:100%;height:120px;background:transparent;color:inherit;border-radius:8px;border:1px solid rgba(255,255,255,0.04);padding:8px}
    .small{font-size:13px;color:var(--muted)}
    .row{display:flex;gap:6px;align-items:center}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Video Hotspot Builder — Full God Mode</h1>
      <div class="drop" id="drop">
        <div style="font-weight:700">Drag & drop video here</div>
        <div class="mini">Supports MP4, WebM — click to browse</div>
        <input id="fileinput" type="file" accept="video/*" multiple />
      </div>

      <div style="margin-top:10px;display:flex;gap:6px;flex-wrap:wrap">
        <button id="newProject">New Project</button>
        <button id="importJson" class="muted-btn">Import JSON</button>
        <button id="exportJson" class="muted-btn">Export JSON</button>
        <button id="downloadTemplate" class="muted-btn">Download Playback Template</button>
      </div>

      <div style="margin-top:12px">
        <label class="small">Project JSON (preview)</label>
        <textarea id="jsonPreview" readonly></textarea>
      </div>

      <div style="margin-top:12px">
        <h3 class="small">Hotspot/Keyframe tips</h3>
        <ul class="small">
          <li>Click video to add keyframe for the currently-selected hotspot (or create new)</li>
          <li>Drag markers to reposition (creates/updates keyframe at current time)</li>
          <li>Use timeline to scrub and add keyframes at exact time.</li>
          <li>Export JSON and drop it into the playback template to render interactive video.</li>
        </ul>
      </div>
    </div>

    <div class="panel">
      <div class="row" style="justify-content:space-between;align-items:center">
        <div>
          <div class="small">Selected video</div>
          <div id="videoTitle" style="font-weight:700">No video loaded</div>
          <div id="videoMeta" class="mini"></div>
        </div>
        <div class="row">
          <button id="playPause" class="muted-btn">Play</button>
          <button id="addHotspot" class="muted-btn">Add Hotspot</button>
          <button id="toggleLabels" class="muted-btn">Toggle Labels</button>
        </div>
      </div>

      <div class="video-wrap" style="margin-top:8px">
        <div class="player-area" id="playerArea">
          <video id="video" controls crossorigin playsinline></video>
        </div>

        <div class="timeline">
          <div class="small">Time</div>
          <input type="range" id="timeRange" min="0" max="100" step="0.01" value="0">
          <div id="timeLabel" class="small">0:00 / 0:00</div>
        </div>

        <div class="row" style="margin-top:8px;align-items:center;gap:8px">
          <label class="small">Selected Hotspot:</label>
          <select id="hotspotSelect"></select>
          <input id="hotspotLabel" placeholder="hotspot label" />
          <button id="deleteHotspot" class="muted-btn">Delete</button>
        </div>

        <div class="hotspot-list" id="hotspotList"></div>
      </div>
    </div>
  </div>

<script>
// Video Hotspot Builder — Full Features (no backend)
// - Drag/drop videos
// - Add hotspots (each hotspot has keyframes, each keyframe has time+x+y)
// - Click on video to add keyframe for selected hotspot (or auto-create)
// - Drag markers to reposition (creates/updates keyframe at current time)
// - Timeline scrubber and play/pause
// - Export/import JSON project
// - Playback template generator (simple HTML that plays video and renders hotspots/keyframes)

const state = { videos: [], selectedVideoIndex: -1, hotspots: [], showLabels:true };

// DOM
const drop = document.getElementById('drop');
const fileinput = document.getElementById('fileinput');
const videoEl = document.getElementById('video');
const playerArea = document.getElementById('playerArea');
const timeRange = document.getElementById('timeRange');
const timeLabel = document.getElementById('timeLabel');
const playPauseBtn = document.getElementById('playPause');
const addHotspotBtn = document.getElementById('addHotspot');
const hotspotSelect = document.getElementById('hotspotSelect');
const hotspotLabel = document.getElementById('hotspotLabel');
const hotspotList = document.getElementById('hotspotList');
const videoTitle = document.getElementById('videoTitle');
const videoMeta = document.getElementById('videoMeta');
const exportJsonBtn = document.getElementById('exportJson');
const importJsonBtn = document.getElementById('importJson');
const jsonPreview = document.getElementById('jsonPreview');
const newProjectBtn = document.getElementById('newProject');
const downloadTemplateBtn = document.getElementById('downloadTemplate');
const toggleLabelsBtn = document.getElementById('toggleLabels');
const deleteHotspotBtn = document.getElementById('deleteHotspot');

// helpers
function uid(n=6){return Math.random().toString(36).slice(2,2+n)}
function formatTime(s){ if(isNaN(s)) return '0:00'; const mm = Math.floor(s/60); const ss = Math.floor(s%60).toString().padStart(2,'0'); return `${mm}:${ss}` }

// File handling
fileinput.addEventListener('change', async (e)=>{ await handleFiles([...e.target.files]); fileinput.value=''; });
['dragenter','dragover','dragleave','drop'].forEach(ev=>drop.addEventListener(ev,(e)=>{e.preventDefault();e.stopPropagation();}));
drop.addEventListener('drop', async (e)=>{ const files=[...e.dataTransfer.files].filter(f=>f.type.startsWith('video/')); await handleFiles(files); });

async function handleFiles(files){
  for(const file of files){
    const url = URL.createObjectURL(file);
    const vid = document.createElement('video'); vid.src = url; await vid.play().catch(()=>{}); // attempt load metadata
    await new Promise(res => vid.onloadedmetadata = res);
    URL.revokeObjectURL(url);
    state.videos.push({ id: uid(8), name: file.name, fileType: file.type, url: URL.createObjectURL(file), naturalWidth: vid.videoWidth, naturalHeight: vid.videoHeight, duration: vid.duration, hotspots: [] });
  }
  if(state.selectedVideoIndex===-1 && state.videos.length>0) selectVideo(0);
  renderVideoList(); updatePreview();
}

function renderVideoList(){ /* minimal: not a visible list for brevity */ }

function selectVideo(i){ state.selectedVideoIndex = i; const v = state.videos[i]; videoEl.src = v.url; videoTitle.textContent = v.name; videoMeta.textContent = `${v.naturalWidth}×${v.naturalHeight} • ${Math.round(v.duration)}s`; state.hotspots = v.hotspots; renderHotspotSelect(); renderHotspotPanel(); }

// simple initial video selection if files added

// timeline
videoEl.addEventListener('loadedmetadata', ()=>{
  timeRange.max = videoEl.duration; timeRange.value = 0; timeLabel.textContent = `${formatTime(0)} / ${formatTime(videoEl.duration)}`;
});
videoEl.addEventListener('timeupdate', ()=>{
  timeRange.value = videoEl.currentTime; timeLabel.textContent = `${formatTime(videoEl.currentTime)} / ${formatTime(videoEl.duration)}`; renderMarkers(); });

timeRange.addEventListener('input', ()=>{ videoEl.currentTime = parseFloat(timeRange.value); });

playPauseBtn.addEventListener('click', ()=>{ if(videoEl.paused) { videoEl.play(); playPauseBtn.textContent='Pause'; } else { videoEl.pause(); playPauseBtn.textContent='Play'; }});

// Hotspots structure: [{ id, label, keyframes: [{time, x, y}], color }]
function createHotspot(){ const h = { id: uid(6), label: 'hotspot-'+(state.hotspots.length+1), keyframes: [], color: randomColor() }; state.hotspots.push(h); renderHotspotSelect(); renderHotspotPanel(); updatePreview(); return h; }

addHotspotBtn.addEventListener('click', ()=>{ const h = createHotspot(); hotspotSelect.value = h.id; hotspotLabel.value = h.label; });

function randomColor(){ const hue = Math.floor(Math.random()*360); return `hsl(${hue} 80% 55%)`; }

function renderHotspotSelect(){ hotspotSelect.innerHTML = ''; state.hotspots.forEach(h=>{ const o = document.createElement('option'); o.value=h.id; o.textContent=h.label; hotspotSelect.appendChild(o); }); }

hotspotSelect.addEventListener('change', ()=>{ const id = hotspotSelect.value; const h = state.hotspots.find(x=>x.id===id); if(h){ hotspotLabel.value = h.label; } renderHotspotPanel(); });

hotspotLabel.addEventListener('change', ()=>{ const h = state.hotspots.find(x=>x.id===hotspotSelect.value); if(h){ h.label = hotspotLabel.value; renderHotspotSelect(); renderHotspotPanel(); updatePreview(); } });

deleteHotspotBtn.addEventListener('click', ()=>{ const id = hotspotSelect.value; const idx = state.hotspots.findIndex(x=>x.id===id); if(idx>=0){ if(!confirm('Delete hotspot?')) return; state.hotspots.splice(idx,1); renderHotspotSelect(); renderHotspotPanel(); updatePreview(); } });

// clicking on video to add keyframe for currently-selected hotspot (or create one)
playerArea.addEventListener('click', (e)=>{
  if(!videoEl.src) return;
  // skip if clicking on marker (we handle marker drag separately)
  if(e.target.classList && e.target.classList.contains('marker')) return;
  const rect = videoEl.getBoundingClientRect();
  const cx = Math.min(Math.max(0, e.clientX - rect.left), rect.width);
  const cy = Math.min(Math.max(0, e.clientY - rect.top), rect.height);
  const nx = Math.round((cx/rect.width)*videoEl.videoWidth);
  const ny = Math.round((cy/rect.height)*videoEl.videoHeight);
  const t = videoEl.currentTime;
  let h = state.hotspots.find(x=>x.id===hotspotSelect.value);
  if(!h){ h = createHotspot(); hotspotSelect.value = h.id; }
  // push keyframe (if nearby time exists, replace)
  const existing = h.keyframes.find(k=>Math.abs(k.time - t) < 0.05);
  if(existing){ existing.x = nx; existing.y = ny; existing.time = t; }
  else { h.keyframes.push({ time: t, x: nx, y: ny }); h.keyframes.sort((a,b)=>a.time-b.time); }
  renderHotspotPanel(); updatePreview(); renderMarkers();
});

// render hotspot cards & keyframes
function renderHotspotPanel(){ hotspotList.innerHTML='';
  state.hotspots.forEach(h=>{
    const card = document.createElement('div'); card.className='hotspot-card';
    const head = document.createElement('div'); head.style.display='flex'; head.style.justifyContent='space-between'; head.innerHTML = `<div><strong style='color:${h.color}'>${h.label}</strong> <span class='mini'>id:${h.id}</span></div><div class='mini'>${h.keyframes.length} keyframes</div>`;
    card.appendChild(head);
    const kfWrap = document.createElement('div'); kfWrap.className='kf-list';
    h.keyframes.forEach((k,ki)=>{
      const kbtn = document.createElement('button'); kbtn.className='muted-btn'; kbtn.textContent = `${formatTime(k.time)} @ ${k.x},${k.y}`;
      kbtn.addEventListener('click', ()=>{ videoEl.currentTime = k.time; });
      const del = document.createElement('button'); del.className='muted-btn'; del.textContent='✕'; del.addEventListener('click', ()=>{ if(confirm('Delete keyframe?')){ h.keyframes.splice(ki,1); renderHotspotPanel(); updatePreview(); renderMarkers(); }});
      kfWrap.appendChild(kbtn); kfWrap.appendChild(del);
    });
    const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='6px';
    const gotoBtn = document.createElement('button'); gotoBtn.className='muted-btn'; gotoBtn.textContent='Jump to first'; gotoBtn.addEventListener('click', ()=>{ if(h.keyframes[0]) videoEl.currentTime = h.keyframes[0].time; });
    actions.appendChild(gotoBtn);
    card.appendChild(kfWrap); card.appendChild(actions);
    hotspotList.appendChild(card);
  });
}

// markers rendered over video
function renderMarkers(){ // remove old markers
  document.querySelectorAll('.marker').forEach(n=>n.remove());
  if(!videoEl.src) return;
  const rect = videoEl.getBoundingClientRect();
  const curr = videoEl.currentTime;
  state.hotspots.forEach(h=>{
    // find interpolation between keyframes for current time
    if(h.keyframes.length===0) return;
    // if before first or after last, clamp
    let p;
    if(curr <= h.keyframes[0].time) { p = { x: h.keyframes[0].x, y: h.keyframes[0].y }; }
    else if(curr >= h.keyframes[h.keyframes.length-1].time) { p = { x: h.keyframes[h.keyframes.length-1].x, y: h.keyframes[h.keyframes.length-1].y }; }
    else {
      // find surrounding
      for(let i=0;i<h.keyframes.length-1;i++){
        const a=h.keyframes[i], b=h.keyframes[i+1];
        if(curr >= a.time && curr <= b.time){
          const t = (curr - a.time) / (b.time - a.time);
          // linear interpolation
          const ix = Math.round(a.x + (b.x - a.x) * t);
          const iy = Math.round(a.y + (b.y - a.y) * t);
          p = { x: ix, y: iy };
          break;
        }
      }
    }
    if(!p) return;
    // convert to client coords
    const left = (p.x / videoEl.videoWidth) * rect.width + rect.left;
    const top = (p.y / videoEl.videoHeight) * rect.height + rect.top;
    const el = document.createElement('div'); el.className='marker'; el.style.left = ( (p.x / videoEl.videoWidth) * 100) + '%'; el.style.top = ( (p.y / videoEl.videoHeight) * 100) + '%';
    el.style.borderColor = '#fff'; el.style.background = h.color; el.dataset.hotspot = h.id; el.title = h.label;
    el.textContent = state.showLabels ? (h.label.length>1? h.label[0] : h.label) : '';
    // position relative to playerArea instead of viewport
    // convert percentages into absolute inside playerArea
    const wrapRect = playerArea.getBoundingClientRect();
    el.style.left = ((p.x / videoEl.videoWidth) * 100) + '%';
    el.style.top = ((p.y / videoEl.videoHeight) * 100) + '%';
    // absolute positioning required: place inside playerArea
    el.style.position = 'absolute'; el.style.transform='translate(-50%,-50%)';
    // attach drag handlers
    makeDraggable(el, h, p);
    playerArea.appendChild(el);
  });
}

// Dragging markers to create/update keyframe at current time
function makeDraggable(el, hotspot, currentPos){
  let dragging=false;
  el.addEventListener('mousedown',(ev)=>{ ev.preventDefault(); dragging=true; el.classList.add('dragging'); document.addEventListener('mousemove', onmove); document.addEventListener('mouseup', onup, {once:true}); });
  function onmove(e){ if(!dragging) return; const rect = videoEl.getBoundingClientRect(); const cx = Math.min(Math.max(0, e.clientX - rect.left), rect.width); const cy = Math.min(Math.max(0, e.clientY - rect.top), rect.height); const nx = Math.round((cx/rect.width)*videoEl.videoWidth); const ny = Math.round((cy/rect.height)*videoEl.videoHeight); // update a transient visual
    el.style.left = (nx / videoEl.videoWidth * 100) + '%'; el.style.top = (ny / videoEl.videoHeight * 100) + '%'; }
  function onup(e){ dragging=false; el.classList.remove('dragging'); document.removeEventListener('mousemove', onmove);
    const rect = videoEl.getBoundingClientRect(); const cx = Math.min(Math.max(0, e.clientX - rect.left), rect.width); const cy = Math.min(Math.max(0, e.clientY - rect.top), rect.height); const nx = Math.round((cx/rect.width)*videoEl.videoWidth); const ny = Math.round((cy/rect.height)*videoEl.videoHeight); const t = videoEl.currentTime;
    // insert or update keyframe near current time
    const h = hotspot;
    const existingIndex = h.keyframes.findIndex(k=>Math.abs(k.time - t) < 0.05);
    if(existingIndex>=0){ h.keyframes[existingIndex].x = nx; h.keyframes[existingIndex].y = ny; h.keyframes[existingIndex].time = t; }
    else { h.keyframes.push({ time: t, x: nx, y: ny }); h.keyframes.sort((a,b)=>a.time-b.time); }
    renderHotspotPanel(); updatePreview(); renderMarkers(); }
}

// export/import
function buildProject(){
  if(state.selectedVideoIndex<0) return { videos: [] };
  const v = state.videos[state.selectedVideoIndex];
  return { video: { name: v.name, url: v.url, naturalWidth: v.naturalWidth, naturalHeight: v.naturalHeight, duration: v.duration }, hotspots: state.hotspots };
}

exportJsonBtn.addEventListener('click', ()=>{ const data = buildProject(); const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='video-hotspots.json'; a.click(); URL.revokeObjectURL(a.href); });

importJsonBtn.addEventListener('click', ()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json'; inp.onchange=async(e)=>{ const f = e.target.files[0]; if(!f) return; const txt = await f.text(); try{ const parsed = JSON.parse(txt); // load into state
    if(parsed.video){ // create placeholder video entry: user must reattach actual file to preserve URLs
      state.videos = [{ id:uid(8), name: parsed.video.name || 'imported', url: parsed.video.url || '', naturalWidth: parsed.video.naturalWidth || 0, naturalHeight: parsed.video.naturalHeight || 0, duration: parsed.video.duration || 0, hotspots: parsed.hotspots || [] }]; selectVideo(0); updatePreview(); alert('Imported. If video URL is missing, re-upload the video and ensure name matches to merge.'); }
    }catch(err){alert('Invalid JSON'); } }; inp.click(); });

function updatePreview(){ jsonPreview.value = JSON.stringify(buildProject(), null, 2); }

// new project
newProjectBtn.addEventListener('click', ()=>{ if(!confirm('Start a new project? Unsaved changes will be lost.')) return; state.videos=[]; state.selectedVideoIndex=-1; state.hotspots=[]; videoEl.src=''; videoTitle.textContent='No video loaded'; videoMeta.textContent=''; updatePreview(); });

// download playback template
downloadTemplateBtn.addEventListener('click', ()=>{
  const project = buildProject(); const tpl = playbackTemplate(project);
  const blob = new Blob([tpl],{type:'text/html'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='video-hotspot-playback.html'; a.click(); URL.revokeObjectURL(a.href);
});

// toggle labels
toggleLabelsBtn.addEventListener('click', ()=>{ state.showLabels=!state.showLabels; renderMarkers(); toggleLabelsBtn.textContent = state.showLabels? 'Hide Labels' : 'Show Labels'; });

// initial call
updatePreview();

// PLAYBACK TEMPLATE generator (simple engine that reads exported JSON and renders hotspots/keyframes)
function playbackTemplate(project){
  const json = JSON.stringify(project).replace(/</g, '\\u003c');
  return `<!doctype html>\n<html><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><title>Interactive Video Playback</title><style>body{background:#071127;color:#e6eef6;font-family:Inter,system-ui,Arial;padding:20px}.wrapper{max-width:1100px;margin:0 auto;position:relative}.player{position:relative}.hotspot{position:absolute;transform:translate(-50%,-50%);width:18px;height:18px;border-radius:50%;border:2px solid #fff;display:flex;align-items:center;justify-content:center;color:#fff;font-size:12px}</style></head><body><div class=\"wrapper\"><h2>Interactive Playback</h2><div class=\"player\"><video id=\"v\" controls playsinline style=\"max-width:100%\"></video></div></div><script>const project = ${json}; const container = document.querySelector('.player'); const video = document.getElementById('v'); if(project.video && project.video.url){ video.src = project.video.url; } else { alert('No video URL in project. Replace project.video.url with your hosted video URL in the exported JSON or use a local file.'); }
  video.addEventListener('loadedmetadata', ()=>{ renderAll(); video.addEventListener('timeupdate', ()=>{ renderAll(); }); });
  function renderAll(){ document.querySelectorAll('.hotspot').forEach(n=>n.remove()); const rect = video.getBoundingClientRect(); project.hotspots.forEach(h=>{ if(!h.keyframes || h.keyframes.length===0) return; const curr = video.currentTime; let p;
    if(curr <= h.keyframes[0].time) p = {x:h.keyframes[0].x,y:h.keyframes[0].y};
    else if(curr >= h.keyframes[h.keyframes.length-1].time) p = {x:h.keyframes[h.keyframes.length-1].x,y:h.keyframes[h.keyframes.length-1].y};
    else { for(let i=0;i<h.keyframes.length-1;i++){ const a=h.keyframes[i], b=h.keyframes[i+1]; if(curr>=a.time && curr<=b.time){ const t = (curr-a.time)/(b.time-a.time); const ix = Math.round(a.x + (b.x-a.x)*t); const iy = Math.round(a.y + (b.y-a.y)*t); p={x:ix,y:iy}; break;} }}
    if(!p) return; const el = document.createElement('div'); el.className='hotspot'; el.style.left=(p.x/project.video.naturalWidth*100)+'%'; el.style.top=(p.y/project.video.naturalHeight*100)+'%'; el.style.background = h.color || '#7c3aed'; el.textContent = h.label? h.label[0] : '';
    // example: show popup when hotspot is visible
    el.addEventListener('click', ()=>{ alert('Clicked: '+(h.label||h.id)); }); container.appendChild(el);
  }); }
</script></body></html>`
}

</script>
</body>
</html>

